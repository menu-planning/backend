from __future__ import annotations

from functools import partial
import time
from typing import TYPE_CHECKING, Any, Callable

import anyio
from src.config.api_config import api_settings
from src.contexts.seedwork.domain.commands.command import Command
from src.contexts.seedwork.domain.event import Event
from src.contexts.seedwork.services.uow import UnitOfWork
from src.logging.logger import StructlogFactory

logger = StructlogFactory.get_logger(__name__)

if TYPE_CHECKING:
    from collections.abc import Coroutine

TIMEOUT = api_settings.timeout

class MessageBus[U: UnitOfWork]:
    """Central orchestrator for command and event dispatching.

    Routes incoming commands to registered handler functions using AnyIO for
    concurrency and timeout/cancellation control. Events generated by commands
    are processed with complete independence - each event handler gets its own
    task group to ensure failures don't cascade. Maintains transaction boundaries
    through UnitOfWork integration.

    Architecture:
        - Commands execute with timeout protection in the main task group
        - Each event handler gets its own task group for complete independence
        - Event handlers are shielded from cancellation to prevent cascading failures
        - Event handler failures are isolated and logged without affecting others
        - All event handlers run concurrently for maximum performance

    Key Benefits:
        - True command-event independence (Cosmic Python compliance)
        - Event handler failures cannot affect command execution
        - Event handler failures cannot affect other event handlers
        - Maximum concurrency with complete error isolation
        - Detailed error logging for each handler failure

    Attributes:
        uow: UnitOfWork instance for transaction management.
        event_handlers: Mapping of event types to handler function lists.
        command_handlers: Mapping of command types to single handler functions.

    Notes:
        Thread-safe: No. Async-safe: Yes. Requires active UnitOfWork context.
        Timeout: Configurable per command via api_settings.timeout.
        FastAPI: Safe when using new instances per request via dependency injection.
        Events: Processed independently - failures don't affect commands or other events.
    """

    def __init__(
        self,
        uow: U,
        event_handlers: dict[type[Event], list[partial[Coroutine]]],
        command_handlers: dict[type[Command], partial[Coroutine]],
    ):
        """Initialize the message bus with handlers and unit of work.

        Args:
            uow: UnitOfWork instance for transaction management.
            event_handlers: Mapping of event types to handler function lists.
            command_handlers: Mapping of command types to single handler functions.
        """
        self.uow = uow
        self.event_handlers = event_handlers
        self.command_handlers = command_handlers

    def _get_handler_name(self, handler) -> str:
        """Extract handler name for logging purposes.
        
        Args:
            handler: Event handler function (may be partial or regular function).
            
        Returns:
            String representation of handler name.
        """
        if isinstance(handler, partial):
            if hasattr(handler.func, '__name__'):
                return handler.func.__name__
            else:
                return handler.func.__class__.__name__
        else:
            if hasattr(handler, '__name__'):
                return handler.__name__
            else:
                return handler.__class__.__name__

    async def handle(self, message: Command, timeout: int = TIMEOUT):
        """Process a single command by dispatching to its handler.

        Routes the command to its registered handler with timeout protection.
        Any events generated by the command are processed independently in
        separate task groups to ensure failure isolation.

        Args:
            message: Domain Command instance to process.
            timeout: Per-command timeout in seconds (default: api_settings.timeout).

        Raises:
            TypeError: If message is not a Command instance.
            TimeoutError: If command execution exceeds timeout.
            Exception: Any exception raised by command handlers.

        Side Effects:
            May emit new events during command processing. Events are processed
            independently and their failures do not affect command execution.
        """
        if not isinstance(message, Command):
            error_message = f"{message} is not a Command"
            logger.error(
                "Invalid message type received",
                action="message_validation_error",
                message_type=type(message).__name__,
                error_message=error_message
            )
            raise TypeError(error_message)

        await self._handle_command(message, timeout)

    async def _completed(self, handler: Callable[[Command], Coroutine[Any, Any, None]], command: Command):
        """Execute command handler and process any new events emitted.

        Runs the provided command handler and collects any new events
        emitted during command processing. Each event handler is processed
        in its own task group to ensure complete independence from other
        event handlers and command execution.

        Args:
            handler: Command handler function to execute.
            command: Command instance to process.

        Side Effects:
            Processes new events emitted during command handling. Each event
            handler runs independently - failures in one handler do not affect
            other handlers or command execution.
        """
        start_time = time.time()
        await handler(command)
        end_time = time.time()
        logger.debug(
            "Command completed",
            action="command_completed",
            command_type=type(command).__name__,
            duration=end_time - start_time
        )
        if isinstance(command, Command):
            new_events = self.uow.collect_new_events()
            # Process each event handler in its own task group for complete independence
            # This ensures that one failing handler cannot affect others or the command
            for event in new_events:
                for handler in self.event_handlers[type(event)]:
                    try:
                        async with anyio.create_task_group() as event_tg:
                            with anyio.CancelScope(shield=True) as scope:
                                event_tg.start_soon(handler, event)
                    except* Exception as exc:
                        # Log this specific event handler failure
                        # Other event handlers continue unaffected
                        handler_name = self._get_handler_name(handler)
                        if isinstance(exc, ExceptionGroup):
                            error_details = []
                            for i, sub_exc in enumerate(exc.exceptions):
                                error_details.append({
                                    'index': i,
                                    'type': type(sub_exc).__name__,
                                    'message': str(sub_exc),
                                    'traceback': sub_exc.__traceback__
                                })
                            logger.error(
                                "Event handler failed",
                                action="event_handler_error",
                                event_type=type(event).__name__,
                                handler_name=handler_name,
                                error_type=type(exc).__name__,
                                error_message=str(exc),
                                error_count=len(exc.exceptions),
                                error_details=error_details,
                                exc_info=True
                            )
                        else:
                            logger.error(
                                "Event handler failed",
                                action="event_handler_error",
                                event_type=type(event).__name__,
                                handler_name=handler_name,
                                error_type=type(exc).__name__,
                                error_message=str(exc),
                                exc_info=True
                            )


    async def _handle_command(self, command: Command, timeout: int = TIMEOUT):
        """Dispatch a command to its single handler within a timeout.

        Executes the registered handler for the command type with timeout
        protection. Events generated by the command are processed in separate
        task groups to ensure independence from command execution.

        Args:
            command: Command instance to dispatch to handler.
            timeout: Maximum execution time in seconds.

        Raises:
            TimeoutError: If command execution exceeds the allowed timeout.
            Exception: Any exception raised by the command handler.

        Notes:
            Commands execute with strict timeout protection. Events are processed
            independently - their failures do not affect command execution.
            Handler exceptions are logged and re-raised for middleware handling.
        """
        logger.debug(
            "Handling command",
            action="command_handling",
            command_type=type(command).__name__
        )
        handler = self.command_handlers[type(command)]
        
        try:
            async with anyio.create_task_group() as tg:
                with anyio.move_on_after(timeout) as scope:
                    tg.start_soon(self._completed, handler, command)
                
                if scope.cancel_called:
                    error_message = f"Timeout handling command {command}"
                    logger.error(
                        "Command handling timeout",
                        action="command_timeout_error",
                        command_type=type(command).__name__,
                        timeout_seconds=timeout,
                        error_message=error_message
                    )
                    raise TimeoutError(error_message)
        except* Exception as exc:
            # Extract detailed error information from ExceptionGroup
            if isinstance(exc, ExceptionGroup):
                # This is an ExceptionGroup - extract individual exceptions
                error_details = []
                for i, sub_exc in enumerate(exc.exceptions):
                    error_details.append({
                        'index': i,
                        'type': type(sub_exc).__name__,
                        'message': str(sub_exc),
                        'traceback': sub_exc.__traceback__
                    })
                logger.error(
                    "Exception occurred while handling command",
                    action="command_handling_error",
                    command_type=type(command).__name__,
                    error_type=type(exc).__name__,
                    error_message=str(exc),
                    error_count=len(exc.exceptions),
                    error_details=error_details,
                    exc_info=True
                )
            else:
                # Single exception
                logger.error(
                    "Exception occurred while handling command",
                    action="command_handling_error",
                    command_type=type(command).__name__,
                    error_type=type(exc).__name__,
                    error_message=str(exc),
                    exc_info=True
                )
            # Re-raise the exception - let the middleware handle it
            raise

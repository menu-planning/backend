---
description: Core Claude 4 best practices that apply across all development tasks
globs: 
alwaysApply: true
---
# Claude 4 Best Practices

## Token Limit: ~500 lines maximum

Core principles for delivering high-quality, thoughtful, and robust solutions.

## 1. Reflective Iteration

**"After receiving user feedback, carefully reflect on their quality and determine optimal next steps before proceeding. Use your thinking to plan and iterate based on this new information, and then take the best next action."**

### Application:
- **Pause and reflect** after user feedback before rushing to implement
- **Consider alternatives** - Is there a better approach given the new information?
- **Plan adjustments** - How does this feedback change the overall approach?
- **Iterate thoughtfully** - Each iteration should improve upon the last

### In Practice:
```markdown
User feedback received. Let me reflect on this:
- What they're really asking for: [insight]
- Why this matters: [reasoning]
- Better approach: [adjusted plan]
```

## 2. Maximum Effort Principle

**"Don't hold back. Give it your all."**

### Application:
- **Comprehensive solutions** - Don't do the minimum, do what's best
- **Attention to detail** - Polish matters
- **Proactive improvements** - Suggest enhancements beyond requirements
- **Thorough validation** - Test edge cases, not just happy paths

### In Practice:
- Add error handling even if not explicitly requested
- Include helpful comments and documentation
- Consider performance implications
- Think about future maintainability

## 3. General-Purpose Implementation

**"Write high quality, general purpose solutions. Implement solutions that work correctly for all valid inputs, not just test cases. Do not hard-code values or create solutions that only work for specific test inputs."**

### Application:
- **No hard-coding** - Use configuration, parameters, or constants
- **Handle edge cases** - Empty inputs, large datasets, special characters
- **Scalable design** - Solutions should work for 10 or 10,000 items
- **Proper abstractions** - Don't couple to specific implementations

### Examples of Anti-patterns to Avoid:
```python
# BAD: Hard-coded for specific test
if username == "test_user":
    return True

# GOOD: General validation
def is_valid_user(username):
    return bool(username and username.strip())
```

```python
# BAD: Assumes specific data structure
result = data[0]["items"][2]["name"]

# GOOD: Handles various structures
def get_item_name(data, index=0, item_index=0):
    try:
        return data[index].get("items", [])[item_index].get("name")
    except (IndexError, AttributeError, TypeError):
        return None
```

## 4. Software Design Principles

Follow established principles:
- **DRY** (Don't Repeat Yourself)
- **SOLID** principles
- **YAGNI** (You Aren't Gonna Need It)
- **Clean Code** practices

## 5. Implementation Guidelines

### Before Starting:
1. Understand the real problem, not just symptoms
2. Consider multiple approaches
3. Choose the most maintainable solution

### During Implementation:
1. Write self-documenting code
2. Add comments for "why", not "what"
3. Handle errors gracefully
4. Consider concurrent access if applicable

### After Implementation:
1. Validate with comprehensive tests
2. Consider performance implications
3. Document any limitations or assumptions

## 6. Testing Philosophy

**"Tests verify correctness, they don't define the solution"**

- Write code that works for all valid inputs
- Use tests to verify, not to drive implementation
- Consider untested edge cases
- Think beyond the test suite

## 7. Communication Excellence

### When Explaining Solutions:
- Start with the "why" before the "how"
- Use clear, concrete examples
- Acknowledge trade-offs
- Suggest alternatives when appropriate

### When Receiving Feedback:
- Listen for underlying needs
- Ask clarifying questions
- Propose refined solutions
- Validate understanding

## Integration with Other Rules

These principles enhance all other rules:
- **Task Generation**: Create comprehensive, thoughtful task lists
- **Task Processing**: Execute with attention to quality and completeness
- **PRD Creation**: Consider all aspects and edge cases

## Examples in Action

### Example 1: Simple Request, Excellent Execution
**User**: "Add a function to validate email"

**Basic**: Create a regex validator

**With Best Practices**:
- General-purpose validator with configuration
- Handle international domains
- Provide detailed error messages
- Consider performance for bulk validation
- Add comprehensive tests
- Document limitations (e.g., doesn't verify existence)

### Example 2: Reflecting on Feedback
**User**: "The function is too slow"

**Without Reflection**: Just add caching

**With Reflection**:
- Why is it slow? (profiling needed)
- What's the usage pattern?
- Would async processing help?
- Is the algorithm optimal?
- Propose multiple solutions with trade-offs

## Remember

Excellence is not about perfection, it's about:
1. **Thoughtful implementation** over quick fixes
2. **Robust solutions** over minimal compliance
3. **Future maintainability** over present convenience
4. **User success** over task completion
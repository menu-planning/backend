---
description: 
globs: 
alwaysApply: false
---
# Enhanced Task List Management v2

Comprehensive guidelines for managing task lists in markdown files, especially for complex projects with multiple phases, testing requirements, and high-risk operations.

## Core Principles

1. **Read and understand the entire task list first** - Identify phases, prerequisites, and critical warnings
2. **Respect task hierarchy** - Some tasks have mandatory prerequisites that cannot be skipped
3. **Testing before implementation** - For refactoring or high-risk tasks, comprehensive testing is non-negotiable
4. **Continuous validation** - Run tests after each change to catch regressions immediately

## Task Implementation Protocol

### 1. Task Analysis (Before Starting)
- **Read the entire task list** to understand:
  - Overall project scope and complexity
  - Phase dependencies and prerequisites
  - Critical warnings and stop signs
  - Success criteria and validation requirements
- **Identify task type**:
  - Simple implementation tasks
  - Refactoring tasks (require comprehensive testing first)
  - High-risk tasks (marked as CRITICAL, WARNING, etc.)
  - Multi-phase projects with dependencies

### 2. Phase-Based Execution
- **Prerequisite phases**: Some phases MUST be completed before others
  - Look for "PHASE 0", "PREREQUISITE", "MANDATORY" markers
  - Never skip prerequisite phases, even if eager to implement
- **Hard stops and checkpoints**:
  - Respect "HARD STOP", "CHECKPOINT", "VERIFICATION" markers
  - These require explicit validation before proceeding
  - Document verification results before continuing
- **Phase completion criteria**:
  - All sub-tasks in a phase must be complete
  - Success criteria must be verified
  - Tests must pass (if applicable)

### 3. Sub-task Execution
- **One sub-task at a time**: Complete each sub-task before starting the next
- **Before starting a sub-task**:
  1. Check the task list to confirm which sub-task is next
  2. Read any associated warnings or requirements
  3. If it's a complex task, outline the implementation approach
  4. For high-risk tasks, confirm understanding with the user
  5. Ask for permission to proceed: "Ready to start [task description]. May I proceed?"
- **During execution**:
  - Follow the task requirements exactly
  - Run validation commands as specified
  - Document any issues or discoveries
- **After completion**:
  1. Run any specified validation (tests, linting, type checking)
  2. Mark the sub-task as complete `[x]`
  3. Update any relevant documentation
  4. Report completion status
  5. Wait for user approval before continuing

### 4. Testing-First Protocol (For Refactoring/High-Risk Tasks)

When a task list emphasizes testing (look for "NO TESTING = NO [ACTION]" warnings):

- **Mandatory test coverage BEFORE implementation**:
  1. Create comprehensive unit tests for existing functionality
  2. Achieve specified coverage targets (often 95%+)
  3. Create mock objects to isolate components
  4. Test all edge cases and error conditions
  5. Establish performance baselines
  6. Document current behavior through tests
- **Test independence**: Tests should not depend on external systems (database, APIs)
- **Regression testing**: Run ALL tests after EACH change
- **Performance monitoring**: Track execution time and resource usage

### 5. Risk Management

For tasks marked as "CRITICAL", "HIGH-RISK", or with warnings:

- **Extra validation steps**:
  1. Double-check understanding of requirements
  2. Create rollback plan before making changes
  3. Test in isolation first
  4. Validate with incremental changes
  5. Monitor for side effects
- **Documentation requirements**:
  - Document all assumptions
  - Note any discovered issues or limitations
  - Keep detailed logs of changes
- **User confirmation**: Always get explicit approval for high-risk operations

## Task List Maintenance

### 1. Status Updates
- **Mark tasks complete** `[x]` immediately upon completion
- **Update parent tasks** when all sub-tasks are complete
- **Add new tasks** as they emerge during implementation
- **Document blockers** with clear descriptions

### 2. Relevant Files Section
Maintain an accurate list of:
- Every file created or modified
- Purpose of each file (one-line description)
- Relationship between files
- Test files associated with implementation files

### 3. Progress Reporting
After each sub-task:
- Report what was completed
- Note any issues encountered
- Highlight any deviations from plan
- Suggest next steps if unclear

## Success Criteria Tracking

For task lists with defined success criteria:

1. **Measurable metrics**:
   - Test coverage percentages
   - Performance benchmarks
   - Compatibility checks
   - Error rates
2. **Verification checklist**:
   - Create checklist from success criteria
   - Validate each item before phase completion
   - Document verification results
3. **Continuous monitoring**:
   - Track metrics throughout implementation
   - Alert on degradation
   - Maintain audit trail

## Special Execution Modes

### 1. High-Risk Refactoring Mode
When task involves refactoring critical code:
- Complete ALL testing tasks first (usually Phase 0)
- Never skip to implementation phases
- Maintain backward compatibility
- Run regression tests continuously

### 2. Multi-Phase Project Mode
For projects with multiple phases:
- Complete phases in order
- Verify phase completion before proceeding
- Review phase dependencies
- Get approval at phase boundaries

### 3. Emergency Stop Protocol
If you encounter:
- Failing tests after changes
- Unexpected behavior
- Missing prerequisites
- Unclear requirements

**STOP IMMEDIATELY** and:
1. Document the issue
2. Revert changes if necessary
3. Consult with user
4. Do not proceed until resolved

## Command Execution Guidelines

### 1. Testing Commands
- Use the project's test runner (e.g., `./manage.py test`, `poetry run pytest`)
- Run with coverage when specified
- Execute performance tests if required
- Validate all test marks (unit, integration, e2e)

### 2. GitHub CLI Operations
- Use `gh` for all GitHub operations
- Verify authentication before executing
- Preview commands before execution
- Wait for user approval

### 3. Python Execution
- Always use Poetry: `poetry run python`
- Ensure dependencies are installed
- Use correct Python version
- Handle virtual environments properly

### 4. Validation Commands
- Linting: `poetry run flake8`, `poetry run ruff`
- Type checking: `poetry run mypy`
- Formatting: `poetry run black`
- Security: `poetry run bandit`

## AI Behavior Requirements

1. **Proactive task tracking**: Use TodoWrite/TodoRead tools frequently
2. **Clear communication**: Explain approach before implementation
3. **Validation focus**: Prioritize testing and verification
4. **Risk awareness**: Identify and communicate potential risks
5. **User collaboration**: Seek clarification when uncertain

## Examples of Task Types

### Type 1: Simple Implementation
- No critical warnings
- Clear requirements
- Low risk of side effects
- Standard one-by-one execution

### Type 2: Testing-First Refactoring
- "NO TESTING = NO REFACTORING" warnings
- Mandatory Phase 0 testing
- Complex interdependencies
- High risk of regressions

### Type 3: Multi-Phase Project
- Numbered phases with dependencies
- Checkpoints between phases
- Success criteria per phase
- Cumulative validation

### Type 4: High-Risk Operations
- CRITICAL/WARNING markers
- Database migrations
- API changes
- Security-related tasks

## Final Checklist Before Starting

- [ ] Read entire task list
- [ ] Identified task type and risk level
- [ ] Understood phase dependencies
- [ ] Located success criteria
- [ ] Found validation commands
- [ ] Prepared rollback strategy (if needed)
- [ ] Ready to track progress meticulously

Remember: **Respect the complexity**. When in doubt, test more, validate more, and communicate more.